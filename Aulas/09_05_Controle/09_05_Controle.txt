-- C e C++ oferecem diferentes formas de implementar laços. Exemplos?

#include <iostream>

int factF(int n) {
  int a = 1;
  for (int i = 2; i <= n; i++) {
    a *= i;
  }
  return a;
}

int factW(int n) {
  int a = 1;
  while (n > 1) {
    a *= n;
    n--;
  }
  return a;
}

int factDoW(int n) {
  if (n < 1) {
    return 1;
  } else {
    int a = 1;
    do {
      a *= n;
      n--;
    } while (n > 1);
    return a;
  }
}

int main() {
  int n;
  std::cin >> n;
  std::cout << factF(n) << std::endl;
  std::cout << factW(n) << std::endl;
  std::cout << factDoW(n) << std::endl;
}

-- Seria possível implementar a função fatorial sem o laço, usando a recursão?

int factR(int n) {
  return n < 1 ? 1 : n * factR(n-1);
}

Exercício:
==========
Leia um conjunto de números da entrada, e para cada um deles, imprima seu fatorial,
em ordem crescente.

-- Qual seria a estrutura desse programa?
1. Leia a entrada
2. Ordene a entrada
3. Imprima os fatoriais

-- Implemente a leitura e a escrita dos dados:

#include <vector>
#include <iostream>

int factR(int n) { return n < 1 ? 1 : n * factR(n-1); }

void read_vec(std::vector<unsigned>& v) {
  unsigned input = 0;
  while (std::cin >> input) {
    v.push_back(input);
  }
}

void print_vec(std::vector<unsigned>& v) {
  for (unsigned u: v) {
    std::cout << factR(u) << std::endl;
  }
}

-- E como ordenar o vetor?

#include <algorithm>    // std::sort

int main() {
  std::vector<unsigned> v;
  read_vec(v);
  std::sort(v.begin(), v.end());
  print_vec(v);
}

-- O que são esse begin e esse end?

void print_vecI(std::vector<unsigned>& v) {
  for (std::vector<unsigned>::iterator p = v.begin(); p != v.end(); p++) {
    std::cout << factR(*p) << std::endl;
  }
}

-- É sempre necessário escrever o tipo inteiro do iterador?

void print_vecA(std::vector<unsigned>& v) {
  for (auto p = v.begin(); p != v.end(); p++) {
    std::cout << factR(*p) << std::endl;
  }
}

-- O que é este 'auto'?

-- E dá para iterar de trás para frente?

void print_vecRI(std::vector<unsigned>& v) {
  std::vector<unsigned>::reverse_iterator p;
  for (p = v.rbegin(); p != v.rend(); p++) {
    std::cout << factR(*p) << std::endl;
  }
}

-- Dá para usar o 'auto' de trás para frente?

void print_vecRA(std::vector<unsigned>& v) {
  for (auto p = v.rbegin(); p != v.rend(); p++) {
    std::cout << factR(*p) << std::endl;
  }
}